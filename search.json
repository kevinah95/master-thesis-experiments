[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "master-thesis-experiments",
    "section": "",
    "text": "Prefacio\nEl artículo “Metodología para el análisis y medición automáticos de sistemas de software” aborda el problema de la rotación de programadores en proyectos de software. La rotación de programadores puede tener un impacto negativo significativo en un proyecto, ya que puede provocar la pérdida de conocimiento crítico, la disminución de la productividad y el aumento de los costes.\nLos métodos de gestión de proyectos por lo general no consideran el grado y la complejidad de los aportes que realizan los desarrolladores y el riesgo que tiene asociada su eventual salida de un proyecto. Por ello, se requiere de métodos que permitan conocer la complejidad de los cambios que realizan, y permitan medir la concentración de conocimiento y el nivel de dependencia que se tiene de cada programador durante el desarrollo y mantenimiento del software.\nEl artículo propone un método para medir el riesgo asociado a la salida de un programador de un proyecto de software. El método se basa en la hipótesis de que el grado de conocimiento de un programador sobre un sistema está relacionado con la complejidad de los cambios que realiza.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "chapters/ch01/install.html",
    "href": "chapters/ch01/install.html",
    "title": "1  Instalación",
    "section": "",
    "text": "1.1 Generación de datos de entrada (Opcional)\nPara renderizar el libro usted mismo, siga estos pasos:\nEn esta sección se explica cómo instalar los proyectos para la generación de datos de entrada.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "chapters/ch01/install.html#sec-generación-de-datos-de-entrada",
    "href": "chapters/ch01/install.html#sec-generación-de-datos-de-entrada",
    "title": "1  Instalación",
    "section": "",
    "text": "1.1.1 Instalar GAST\nEste proyecto utiliza Maven. Para utilizar las funcionalidades proporcionadas por este proyecto, se debe instalar la dependencia Maven de este proyecto en el repositorio local de Maven (p.ej. ~/.m2/repository). Los pasos son los siguientes:\n\nClonar el repositorio Softlab-TEC/GAST.\nCambiar de branch a develop-GAST.\nCorrer mvn install.\n\nEste proceso instalará el proyecto en la siguiente dirección:\n\n~/.m2/repository/avib/coderetriever/avib.coderetriever.gast.\n\n\n\n1.1.2 Instalar Mapper\nTodas las dependencias se descargan automáticamente por Maven, pero una de esas dependencias, el proyecto GAST, debe ser instalado manualmente. Puede ver las dependencias de Maven en el archivo Pom.xml de este proyecto.\nPara ello, es importante realizar primero la Instalación del GAST. Luego se pueden seguir los siguientes pasos:\n\nClonar el repositorio Softlab-TEC/Mapper.\nSustituir la dependencia por:\n&lt;!-- https://mvnrepository.com/artifact/org.eclipse.jdt/org.eclipse.jdt.core --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.eclipse.jdt&lt;/groupId&gt;\n    &lt;artifactId&gt;org.eclipse.jdt.core&lt;/artifactId&gt;\n    &lt;version&gt;3.22.0&lt;/version&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;!-- declare the exclusion here --&gt;\n            &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;\n            &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;!-- declare the exclusion here --&gt;\n            &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;\n            &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;\n    &lt;artifactId&gt;org.eclipse.core.runtime&lt;/artifactId&gt;\n    &lt;version&gt;3.13.0&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;!-- declare the exclusion here --&gt;\n            &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;\n            &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.eclipse.platform&lt;/groupId&gt;\n    &lt;artifactId&gt;org.eclipse.equinox.common&lt;/artifactId&gt;\n    &lt;version&gt;3.14.100&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\nCorrer mvn install.\n\nEste proceso instalará el proyecto en la siguiente dirección:\n\n~/.m2/repository/avib/coderetriever/avib.coderetriever.mapper.\n\n\n\n1.1.3 Instalar Analyzer\nTodas las dependencias se descargan automáticamente por Maven, pero dos de esas dependencias, GAST y Mapper, deben ser instaladas manualmente. Puede ver las dependencias de Maven en el archivo Pom.xml de este proyecto.\nPara ello, es importante realizar primero la Instalación del GAST, luego Instalar Mapper. Luego se pueden seguir los siguientes pasos:\n\nClonar el repositorio Softlab-TEC/Analyzer.\nCambiar de branch a develop-metrics.\nUtilizar sdkman para instalar Java 8:\n# .sdkmanrc\n# Enable auto-env through the sdkman_auto_env config\n# Add key=value pairs of SDKs to use below\njava=8.0.352-amzn\nCambiar el pom.xml a Java 8:\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            ...\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;/source&gt;\n                &lt;target&gt;1.8&lt;/target&gt;\n                ...\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\nEl archivo src/main/java/metrics/overview/sizeandcomplexity/nom/NomMetric.java va a fallar, entonces hay que agregar:\n\nEl import de import org.apache.commons.lang3.StringUtils;.\nReemplazar methodName.asText().isBlank() a StringUtils.isBlank(methodName.asText()).\n\nCorrer mvn compile.\nCorrer mvn install.\n\nEste proceso instalará el proyecto en la siguiente dirección:\n\n~/.m2/repository/avib/coderetriever/avib.coderetriever.analyzer.\n\n\n\n1.1.4 Instalar Repositoryminer\nLuego de instalar los 3 proyectos anteriores (GAST, Mapper, Analyzer). Se necesita instalar kevinah95/repositoryminer. Para ello se pueden seguir estos pasos:\n\nClonar el repositorio kevinah95/repositoryminer.\nEste proyecto utiliza sdkman para configurar el ambiente. Para instalar estos SDKs que faltan, basta con escribir:\nsdk env install\nPara cambiar a la configuración presente en el archivo .sdkmanrc, simplemente ejecute el siguiente comando:\nsdk env\nEste comando instalará Java 11 y Gradle 7.\nCorrer el comando: gradle build.\nCorrer el comando: gradle publishToMavenLocal.\n\nEste proceso instalará el proyecto en la siguiente dirección:\n\n~/.m2/repository/org/repositoryminer/core.\n\n\n\n1.1.5 Correr RepominerRunner\nUna vez instalados los proyectos anteriores (Repositoryminer, GAST, Mapper, Analyzer). Podemos correr el proyecto para la generación de datos de entrada:\n\nClonar el repositorio kevinah95/repominer-runner.\nModificar la conexión con Mongo (línea 27).\nModificar la descripción del repositorio en estudio (línea 35).\n\nUna vez que se haya ejecutado el procesamiento se almacenara en la base de datos Mongo, previamente configurada.\n\n\n1.1.6 Correr API\nPara poder extraer la información necesario como datos de entrada se puede utilizar un API. Un ejemplo de su implementación se encuentra en el repositorio kevinah95/nextjs-with-mongodb-api. Para ejecutar el proyecto es necesario seguir estos pasos:\n\nClonar el repositorio kevinah95/nextjs-with-mongodb-api.\nRenombrar el archivo .env.local.example por .env.local.\nCambiar la variable de ambiente en el archivo .env.local:\nMONGODB_URI - Cadena de conexión a MongoDB. Si se utiliza MongoDB Atlas, se puede encontrar haciendo clic en el botón “Conectar” del clúster.\nEjecutar Next.js en modo de desarrollo:\nnpm install\nnpm run dev\n\n# sino\n\nyarn install\nyarn dev\nLa aplicación debería estar funcionando en http://localhost:3000. Puede hacer uso del API por ejemplo:\n\napi/commits/:repositoryId: Para obtener la lista de commits por repositorio.\napi/repositories: Para obtener la información de los repositorios minados.\n\n\nLa lista de commits funcionará como datos de entrada para este repositorio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalación</span>"
    ]
  },
  {
    "objectID": "chapters/ch02/architecture.html",
    "href": "chapters/ch02/architecture.html",
    "title": "2  Arquitectura",
    "section": "",
    "text": "La arquitectura se basa en cliente/servidor, en la que los procesos de ETL y AAES son ejecutados por el servidor y EVCES es un notebook hosteado en ObservableHQ y donde el VVAH se accede mediante su propio API. Los diferentes módulos y componentes de la arquitectura se describen en el siguiente orden: recuperación de datos, análisis de datos y representación visual.\nEn la arquitectura se muestran dos módulos o gestores de tareas:\n\nETL y Analizador Avanzado de la Evolución del Software (AAES).\nVinculador de Vistas y Analizador de Hechos (VVAH).\n\nEstos gestores son los orquestadores que tienen la tarea del preprocesamiento de los datos donde en primera instancia (ETL) se procesan los datos extraídos del repositorio de soluciones programadas para una primera fase de transformación, detección de métricas en la evolución del software (AAES) y luego la cargar de datos a la base de datos. Luego de ser cargados, el orquestador encargado de vincular y analizar los hechos lee la base, obtiene los datos integrados (commit, desarrollador del commit, archivos que fueron modificados), procesa los datos integrados para una segunda fase de transformación hasta convertirlos en el historial de cambios con desarrolladores normalizados. Estos dos procesos llamados orquestadores son los encargados de enviar mensajes que activen las dos visualizaciones que les siguen.\nLos otros dos gestores de tareas dependen de los orquestadores, pero son independientes uno del otro:\n\nVisualización de la complejidad única.\nVisualización del esfuerzo total de los desarrolladores.\n\nEste proyecto depende de:\n\nGAST\nMapper\nAnalyzer\n\nPara minar se utiliza:\n\nrepositoryminer",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arquitectura</span>"
    ]
  },
  {
    "objectID": "chapters/ch03/experiments.html",
    "href": "chapters/ch03/experiments.html",
    "title": "3  Experimentos",
    "section": "",
    "text": "3.1 Visualizaciones",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Experimentos</span>"
    ]
  },
  {
    "objectID": "chapters/ch03/experiments.html#visualizaciones",
    "href": "chapters/ch03/experiments.html#visualizaciones",
    "title": "3  Experimentos",
    "section": "",
    "text": "3.1.1 Complejidad única\n\n\n\n\nVer código\nviewof selectedRepository = Inputs.select(\n  d3.group(repos, (repo) =&gt; repo.repository.name),\n  { label: \"Elegir repositorio\" }\n)\n\nstadistics = {\n  \n  const data2 = footerdata.filter(v =&gt; v.title === \"Complejidad única\")\n  \n  const df22 = aq.from(data2).fold(aq.not('title', 'cx'), { as: ['dev', 'metric'] })\n  \n  return vl.markBar()\n            .data(df22)\n            .encode(\n              vl.y().fieldN('dev').title('Desarrolladores'),\n              vl.x().fieldQ('metric').title('Complejidad única')\n            )\n            .width(160)\n            .height(560)\n            .render()\n}\n\nviewof riskPercentile = Inputs.range([0, 100], {step: 1, label: \"Percentil de riesgo\", value: 70})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nt = {\n  const holderEl = document.createElement(\"div\");\n\n  // tag ids\n  const header_container_id = \"unique_header\";\n  const body_container_id = \"unique_body\";\n  const footer_container_id = \"unique_footer\";\n\n  // create\n  const header_table = create_header(unique_cx_metrics, header_container_id);\n  const body_table = create_body(unique_cx_metrics, body_container_id);\n  const footer_table = create_footer(unique_cx_metrics, footer_container_id);\n\n  // append to holder\n  holderEl.appendChild(header_table.element);\n  holderEl.appendChild(body_table.element);\n  holderEl.appendChild(footer_table.element);\n\n  // helper to support scrolling\n  header_table.on(\"scrollHorizontal\", function (left) {\n    document.querySelector(\n      `#${body_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n    document.querySelector(\n      `#${footer_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n  });\n\n  body_table.on(\"scrollHorizontal\", function (left) {\n    document.querySelector(\n      `#${header_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n    document.querySelector(\n      `#${footer_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n  });\n\n  footer_table.on(\"scrollHorizontal\", function (left) {\n    document.querySelector(\n      `#${header_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n    document.querySelector(\n      `#${body_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n  });\n\n  footer_table.on(\"dataProcessed\", function(){\n    mutable footerdata = footer_table.getData();\n  });\n\n\n  // cell edit\n  header_table.on(\"cellEdited\", function (cell) {\n    //cell - cell component\n    const cellValue = cell.getValue();\n    const field = cell.getField();\n    console.log(cellValue, field)\n\n    const tree_table_data = body_table.getData();\n\n    const footer_table_data = footer_table.getData();\n\n    // body calcs\n\n    //console.log('tree_table_data',tree_table_data)\n\n    const new_tree = tree_table_data.map((p, p_index) =&gt; {\n      p[field] = cellValue\n        ? unique_cx_metrics.tree_summary_data.children[p_index][field]\n        : 0;\n      p.children = p.children.map((c, c_index) =&gt; {\n        c[field] = cellValue\n          ? unique_cx_metrics.tree_summary_data.children[p_index].children[\n              c_index\n            ][field]\n          : 0;\n        c.children = c.children.map((m, m_index) =&gt; {\n          m[field] = cellValue\n            ? unique_cx_metrics.tree_summary_data.children[p_index].children[\n                c_index\n              ].children[m_index][field]\n            : 0;\n          return m;\n        });\n        return c;\n      });\n      return p;\n    });\n\n    //console.log('new_tree',new_tree)\n\n    // footer calcs\n    footer_table_data[0][field] = cellValue\n      ? unique_cx_metrics.tree_summary_data[field]\n      : 0;\n\n    const total_cx_data = footer_table_data[0];\n\n    _.forIn(total_cx_data, (value, key) =&gt; {\n      if (key != \"cx\" && key != \"title\") {\n        footer_table_data[1][key] = +(\n          (value * 100) /\n          total_cx_data[\"cx\"]\n        ).toFixed(2);\n      }\n    });\n\n    //console.log(footer_table_data);\n\n    const unique_cx_data = calculate_unique_cx_summary(\n      new_tree,\n      unique_cx_metrics.devs_with_zero,\n      unique_cx_metrics.devs_with_non_zero\n    );\n\n    footer_table_data[2] = { ...unique_cx_data, title: \"Complejidad única\" };\n    \n\n    const percentage_unique_cx_data = _.transform(\n      unique_cx_data,\n      (result, value, key) =&gt; {\n        result[key] = +((value * 100) / total_cx_data[\"cx\"]).toFixed(2);\n      },\n      {}\n    );\n\n    footer_table_data[3] = {\n      ...percentage_unique_cx_data,\n      title: \"Complejidad única (%)\"\n    };\n\n    const knowledge_remaining = calculate_knowledge_remaining(new_tree, unique_cx_metrics.devs_with_non_zero);\n\n    const knowledge_remaining_percentage = 100 - (+((knowledge_remaining * 100) / total_cx_data[\"cx\"]).toFixed(2))\n\n    footer_table_data[4] = {\n      cx: knowledge_remaining_percentage,\n      title: \"Conocimiento restante\"\n    };\n\n    footer_table.replaceData(footer_table_data);\n    body_table.replaceData(tree_table_data);\n  });\n\n  // return\n  return holderEl;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Experimentos</span>"
    ]
  },
  {
    "objectID": "chapters/ch03/experiments.html#apéndice",
    "href": "chapters/ch03/experiments.html#apéndice",
    "title": "3  Experimentos",
    "section": "3.2 Apéndice",
    "text": "3.2 Apéndice\n\n3.2.1 Variables y config\n\n\nVer código\nchanges = selectedRepository[0].changes\n\n\n\n\n\n\n\n\n\nVer código\nmutable footerdata = null;\n\n\n\n\n\n\n\n\n\nVer código\nunique_cx_metrics = {\n  const grouped_data = d3.hierarchy(\n    changes_with_dev_key\n      .groupby(\"_package\", \"_class\", \"method\")\n      .orderby(aq.desc(\"date\"))\n      .derive({ last: aq.rolling((d) =&gt; op.first_value(d.cur_m_cx)) })\n      .orderby(\"date\")\n      .groupby(\"_package\", \"_class\", \"method\", \"last\")\n      .pivot({ key: (d) =&gt; d.dev_key }, { value: (d) =&gt; op.any(d.last) || 0 })\n      .groupby(\"_package\", \"_class\")\n      .objects({ grouped: \"map\" })\n  );\n\n  const tree_summary_data = grouped_data.copy().eachAfter((d) =&gt; {\n    devs_by_email.forEach((k) =&gt; {\n      d[k] = d.children ? _.sumBy(d.children, k) : d.data[k] || 0;\n    });\n\n    d[\"cx\"] = d.children ? _.sumBy(d.children, \"cx\") : d.data[\"last\"] || 0;\n\n    d.title = d.data[0] || d.data.method;\n  });\n\n  const { devs_with_zero, devs_with_non_zero } = _.chain(devs_by_email)\n    .partition((key) =&gt; _.every(tree_summary_data.children, (d) =&gt; d[key] == 0))\n    .map(_.sortBy)\n    .thru((v) =&gt; ({ devs_with_zero: v[0], devs_with_non_zero: v[1] }))\n    .value();\n\n  const picked = _.concat(devs_with_non_zero, [\"cx\"]);\n\n  const total_cx_data = _.pick(tree_summary_data, picked);\n\n  const percentage_cx_data = _.transform(\n    total_cx_data,\n    (result, value, key) =&gt; {\n      result[key] = +((value * 100) / total_cx_data[\"cx\"]).toFixed(2);\n    },\n    {}\n  );\n\n  const unique_cx_data = calculate_unique_cx_summary(\n    tree_summary_data.children,\n    devs_with_zero,\n    devs_with_non_zero\n  );\n\n  const percentage_unique_cx_data = _.transform(\n    unique_cx_data,\n    (result, value, key) =&gt; {\n      result[key] = +((value * 100) / total_cx_data[\"cx\"]).toFixed(2);\n    },\n    {}\n  );\n\n  const knowledge_remaining = calculate_knowledge_remaining(tree_summary_data.children,devs_with_non_zero);\n  const knowledge_remaining_percentage = 100 - (+((knowledge_remaining * 100) / total_cx_data[\"cx\"]).toFixed(2))\n\n  return {\n    grouped_data,\n    tree_summary_data,\n    devs_with_zero,\n    devs_with_non_zero,\n    total_cx_data,\n    percentage_cx_data,\n    unique_cx_data,\n    percentage_unique_cx_data,\n    knowledge_remaining,\n    knowledge_remaining_percentage\n  };\n}\n\n\n\n\n\n\n\n\n3.2.1.1 Limpiar devs\n\n\nVer código\nchanges_with_dev_key = {\n  const changes_with_dev_email_splitted = aq.from(changes)\n    .derive({ splitted: (d) =&gt; op.split(d.dev_email, \"@\") })\n    .derive({ username: (d) =&gt; op.lower(d.splitted[0]) }) // normalize to lower\n    .derive({ domain: (d) =&gt; op.lower(d.splitted[1]) }) // normalize to lower\n    .derive({\n      new_email: (d) =&gt; d.username + (d.domain ? \"@\" + d.domain : \"\")\n    });\n\n  const changes_with_dev_email_splitted_objects =\n    changes_with_dev_email_splitted.objects();\n\n  const use_username =\n    _.chain(changes_with_dev_email_splitted_objects.map((d) =&gt; d.username))\n      .uniq()\n      .size()\n      .value() ==\n    _.chain(changes_with_dev_email_splitted_objects.map((d) =&gt; d.new_email))\n      .uniq()\n      .size()\n      .value();\n\n  return aq.from(changes_with_dev_email_splitted)\n    .derive({\n      dev_key: aq.escape((d) =&gt; (use_username ? d.username : d.new_email))\n    })\n    //.view();\n}\n\n\n\n\n\n\n\n\n\nVer código\ndevs_by_email = changes_with_dev_key\n .dedupe('dev_key')\n .select('dev_key')\n .filter(d =&gt; d.dev_key !== \"noreply@github.com\" && d.dev_key !== \"noreply\") // filter noreply github\n .orderby('dev_key')\n .array('dev_key')\n\n\n\n\n\n\n\n\n\n\n3.2.2 Tabulator\n\n\nVer código\nTabulator = require(\"tabulator-tables@5.5.2\")\n\n\n\n\n\n\n\n\n\n3.2.3 Helper Functions\n\n\nVer código\ncreate_header = (metrics, containerId) =&gt; {\n  const data = _.chain(metrics.devs_with_non_zero)\n    .reduce((p, v) =&gt; ({ ...p, [v]: true }), {})\n    .thru((v) =&gt; [v])\n    .value();\n  \n  const container = document.createElement(\"DIV\");\n  container.id = containerId;\n  const table = new Tabulator(container, {\n    data: data,\n    layout: \"fitDataStretch\",\n    //height: 260,\n    headerSort: false,\n    nestedFieldSeparator: false,\n    columns: [\n      {\n        title: \"Software Item\",\n        headerSort: false,\n        width: 200,\n        responsive: 0,\n        frozen: true\n      },\n      ...metrics.devs_with_non_zero.map((d) =&gt; ({\n        title: d,\n        field: d,\n        hozAlign: \"center\",\n        headerSort: false,\n        editor: true,\n        width: 50,\n        headerVertical: \"flip\",\n        formatter: \"tickCross\"\n      })),\n      { title: \"Complejidad\", width: 150, headerSort: false }\n    ]\n  });\n  return table;\n}\n\n\n\n\n\n\n\n\n\nVer código\ncreate_body = (metrics, containerId) =&gt; {\n  const data = _.cloneDeep(metrics.tree_summary_data).children;\n  //const footerElement = footer_table.element;\n  const container = document.createElement(\"DIV\");\n  container.id = containerId;\n\n  const table = new Tabulator(container, {\n    data,\n    dataTree: true,\n    dataTreeChildField: \"children\",\n    height: 350,\n    headerVisible: false, \n    layout: \"fitDataStretch\",\n    nestedFieldSeparator: false,\n    columns: [\n      {\n        title: \"Software Item\",\n        field: \"title\",\n        width: 200,\n        responsive: 0,\n        frozen: true\n      },\n\n      ...metrics.devs_with_non_zero.map((d) =&gt; ({\n        [\"title\"]: d,\n        [\"field\"]: d,\n        width: 50,\n        headerVertical: \"flip\"\n      })),\n      { title: \"Complejidad\", field: \"cx\", width: 150 }\n    ],\n    //footerElement: footerElement\n  });\n\n  return table;\n}\n\n\n\n\n\n\n\n\n\nVer código\ncreate_footer = (metrics, containerId) =&gt; {\n  const data = [\n    {\n      title: \"Complejidad total\",\n      ...metrics.total_cx_data\n    },\n    {\n      title: \"Complejidad total (%)\",\n      ...metrics.percentage_cx_data\n    },\n    {\n      title: \"Complejidad única\",\n      ...metrics.unique_cx_data\n    },\n    {\n      title: \"Complejidad única (%)\",\n      ...metrics.percentage_unique_cx_data\n    },\n    {\n      title: \"Conocimiento restante\",\n      cx: metrics.knowledge_remaining_percentage\n    }\n  ];\n\n  const container = document.createElement(\"DIV\");\n  container.className = \"tabulator-footer\";\n  container.id = containerId;\n  const table = new Tabulator(container, {\n    data,\n    //height: 150,\n    layout: \"fitDataStretch\",\n    headerVisible: false,\n    nestedFieldSeparator: false,\n    cssClass: \"tabulator-footer\",\n    rowFormatter: function (row) {\n      const row_data = row.getData();\n      \n      if (row_data.title == \"Conocimiento restante\") {\n        if(row_data.cx &lt; riskPercentile){\n          row.getElement().style.backgroundColor = \"#ff0000\";\n          row.getElement().style.color = \"#fff\";\n          row.getElement().style.fontWeight = \"bold\";\n        }\n      }\n    },\n    columns: [\n      {\n        title: \"Software Item\",\n        field: \"title\",\n        width: 200,\n        responsive: 0,\n        frozen: true\n      },\n      ...metrics.devs_with_non_zero.map((d) =&gt; ({\n        [\"title\"]: d,\n        [\"field\"]: d,\n        width: 50,\n        headerVertical: \"flip\"\n      })),\n      { title: \"Complejidad\", field: \"cx\", width: 150 }\n    ]\n  });\n\n  return table;\n}\n\n\n\n\n\n\n\n\n\nVer código\ncalculate_unique_cx_summary = (data, devs_with_zero, devs_with_non_zero) =&gt; {\n  const picked = _.concat(devs_with_non_zero);\n\n  let map = devs_with_non_zero.reduce((p, c) =&gt; {\n    return { ...p, [c]: 0 };\n  }, {});\n\n  //let cx = 0;\n  data.forEach((p, p_index) =&gt; {\n    p.children.forEach((c, c_index) =&gt; {\n      c.children.forEach((m, m_index) =&gt; {\n        //console.log(m)\n        const element = _.pick(m, picked);\n        const values = Object.values(element);\n        //console.log(element)\n        //console.log(values)\n        \n        const max = _.max(values);\n        const sum = _.sum(values);\n        const can = max == sum;\n        if (can && max != 0) {\n          //console.log('max',max, 'sum' , sum)\n          for (const [key, value] of Object.entries(element)) {\n            if (value == max) {\n              //console.log(key, value)\n              map[key] += value;\n              //console.log(map)\n              //cx = value;\n              break;\n            }\n          }\n        }\n      });\n    });\n  });\n\n  //map['cx'] = cx;\n\n  return map;\n}\n\n\n\n\n\n\n\n\n\nVer código\ncalculate_knowledge_remaining = (data, devs_with_non_zero) =&gt; {\n  const picked = _.concat(devs_with_non_zero);\n\n  let result = 0;\n\n  data.forEach((p, p_index) =&gt; {\n    p.children.forEach((c, c_index) =&gt; {\n      c.children.forEach((m, m_index) =&gt; {\n        const element = _.pick(m, picked);\n        const values = Object.values(element);\n        \n        const all_zeros = _.every(values, d =&gt; d == 0);\n        \n        if (all_zeros) {\n          result += m['cx']\n        }\n      });\n    });\n  });\n\n  return result;\n}\n\n\n\n\n\n\n\n\n\n3.2.4 Fetchers\n\n\nVer código\nrepos = {\n  const jgit_cookbook = {\n    repository: { name: \"java.jgit_cookbook\" },\n    changes: await FileAttachment(\"./../../data/java/changes_jgit_cookbook.json\").json()\n  };\n  \n  const uCrop = {\n    repository: { name: \"java.uCrop\" },\n    changes: await FileAttachment(\"./../../data/java/changes_uCrop.json\").json()\n  };\n  \n  const java_jwt = {\n    repository: { name: \"java.java_jwt\" },\n    changes: await FileAttachment(\"./../../data/java/changes_java_jwt.json\").json()\n  };\n  \n  const mapstruct = {\n    repository: { name: \"java.mapstruct\" },\n    changes: await FileAttachment(\"./../../data/java/changes_mapstruct.json\").json()\n  };\n\n  const modelmapper = {\n    repository: { name: \"java.modelmapper\" },\n    changes: await FileAttachment(\"./../../data/java/changes_modelmapper.json\").json()\n  };\n  \n  const javacv = {\n    repository: { name: \"java.javacv\" },\n    changes: await FileAttachment(\"./../../data/java/changes_javacv.json\").json()\n  };\n  \n  const spatial4j = {\n    repository: { name: \"java.spatial4j\" },\n    changes: await FileAttachment(\"./../../data/java/changes_spatial4j.json\").json()\n  };\n  \n  const google_http_java_client = {\n    repository: { name: \"java.google_http_java_client\" },\n    changes: await FileAttachment(\"./../../data/java/changes_google_http_java_client.json\").json()\n  };\n  \n  const jadx = {\n    repository: { name: \"java.jadx\" },\n    changes: await FileAttachment(\"./../../data/java/changes_jadx.json\").json()\n  };\n  \n  const cs_elsa_core = ({\n    repository: {name: \"cs.elsa_core\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_elsa-core.json\").json()\n  });\n  \n  const cs_lively = ({\n    repository: {name: \"cs.lively\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_lively.json\").json()\n  });\n  \n  const cs_changes_m_q_t_tnet = ({\n    repository: {name: \"cs.MQTTNet\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_m_q_t_tnet.json\").json()\n  });\n  \n  \n  const cs_changes_markdig = ({\n    repository: {name: \"cs.markDig\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_markdig.json\").json()\n  });\n  \n  const cs_changes_n_swag = ({\n    repository: {name: \"cs.NSwag\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_n_swag.json\").json()\n  });\n  \n  const cs_changes_pythonnet = ({\n    repository: {name: \"cs.PythonNet\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_pythonnet.json\").json()\n  });\n  \n  const cs_changes_terminal_gui = ({\n    repository: {name: \"cs.Terminal.Gui\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_terminal._gui.json\").json()\n  });\n  \n  const cs_changes_unity_library = ({\n    repository: {name: \"cs.UnityLibrary\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_unity_library.json\").json()\n  });\n  \n  const cs_changes_winAcme = ({\n    repository: {name: \"cs.Win-Acme\"},\n    changes: await FileAttachment(\"./../../data/cs/cs_changes_win-acme.json\").json()\n  });\n\n  \n  \n  return [\n    jgit_cookbook,\n    uCrop,\n    java_jwt,\n    mapstruct,\n    modelmapper,\n    javacv,\n    spatial4j,\n    google_http_java_client,\n    jadx,\n    cs_elsa_core,\n    cs_lively,\n    cs_changes_m_q_t_tnet,\n    cs_changes_markdig,\n    cs_changes_n_swag,\n    cs_changes_pythonnet,\n    cs_changes_terminal_gui,\n    cs_changes_unity_library,\n    cs_changes_winAcme\n  ];\n}\n\n\n\n\n\n\n\n\n\n3.2.5 Imports\n\n\nVer código\nd3 = require(\"d3@7\")\n\n\n\n\n\n\n\n\n\n3.2.6 Notebook Imports\n\n\nVer código\nimport { aq, op } from '@uwdata/arquero'",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Experimentos</span>"
    ]
  }
]