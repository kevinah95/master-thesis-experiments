[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "master-thesis-experiments",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n\nCode\n1 + 1\n\n\n[1] 2",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/ch01/intro.html",
    "href": "chapters/ch01/intro.html",
    "title": "1  Introducción",
    "section": "",
    "text": "El artículo “Un método para determinar el peso de las contribuciones de los programadores para medir el riesgo asociado a su salida de un proyecto” aborda el problema de la rotación de programadores en proyectos de software. La rotación de programadores puede tener un impacto negativo significativo en un proyecto, ya que puede provocar la pérdida de conocimiento crítico, la disminución de la productividad y el aumento de los costes.\nLos métodos de gestión de proyectos por lo general no consideran el grado y la complejidad de los aportes que realizan los desarrolladores y el riesgo que tiene asociada su eventual salida de un proyecto. Por ello, se requiere de métodos que permitan conocer la complejidad de los cambios que realizan, y permitan medir la concentración de conocimiento y el nivel de dependencia que se tiene de cada programador durante el desarrollo y mantenimiento del software.\nEl artículo propone un método para medir el riesgo asociado a la salida de un programador de un proyecto de software. El método se basa en la hipótesis de que el grado de conocimiento de un programador sobre un sistema está relacionado con la complejidad de los cambios que realiza.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "chapters/ch02/structure.html",
    "href": "chapters/ch02/structure.html",
    "title": "2  Estructura/dependencias",
    "section": "",
    "text": "Este proyecto depende de:\n\nGAST\nMapper\nAnalyzer\n\nPara minar se utiliza:\n\nrepositoryminer",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Estructura/dependencias</span>"
    ]
  },
  {
    "objectID": "chapters/ch03/experiments.html#visualizaciones",
    "href": "chapters/ch03/experiments.html#visualizaciones",
    "title": "3  Experimentos",
    "section": "3.1 Visualizaciones",
    "text": "3.1 Visualizaciones\n\n3.1.1 Complejidad única\n\n\n\n\nCode\nviewof selectedRepository = Inputs.select(\n  d3.group(repos, (repo) =&gt; repo.repository.name),\n  { label: \"Elegir repositorio\" }\n)\n\nstadistics = {\n  \n  const data2 = footerdata.filter(v =&gt; v.title === \"Complejidad única\")\n  \n  const df22 = aq.from(data2).fold(aq.not('title', 'cx'), { as: ['dev', 'metric'] })\n  \n  return vl.markBar()\n            .data(df22)\n            .encode(\n              vl.y().fieldN('dev'),\n              vl.x().fieldQ('metric')\n            )\n            .width(160)\n            .height(400)\n            .render()\n}\n\nviewof riskPercentile = Inputs.range([0, 100], {step: 1, label: \"Percentil de riesgo\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nt = {\n  const holderEl = document.createElement(\"div\");\n\n  // tag ids\n  const header_container_id = \"unique_header\";\n  const body_container_id = \"unique_body\";\n  const footer_container_id = \"unique_footer\";\n\n  // create\n  const header_table = create_header(unique_cx_metrics, header_container_id);\n  const body_table = create_body(unique_cx_metrics, body_container_id);\n  const footer_table = create_footer(unique_cx_metrics, footer_container_id);\n\n  // append to holder\n  holderEl.appendChild(header_table.element);\n  holderEl.appendChild(body_table.element);\n  holderEl.appendChild(footer_table.element);\n\n  // helper to support scrolling\n  header_table.on(\"scrollHorizontal\", function (left) {\n    document.querySelector(\n      `#${body_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n    document.querySelector(\n      `#${footer_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n  });\n\n  body_table.on(\"scrollHorizontal\", function (left) {\n    document.querySelector(\n      `#${header_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n    document.querySelector(\n      `#${footer_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n  });\n\n  footer_table.on(\"scrollHorizontal\", function (left) {\n    document.querySelector(\n      `#${header_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n    document.querySelector(\n      `#${body_container_id} .tabulator-tableholder`\n    ).scrollLeft = left;\n  });\n\n  footer_table.on(\"dataProcessed\", function(){\n    mutable footerdata = footer_table.getData();\n  });\n\n\n  // cell edit\n  header_table.on(\"cellEdited\", function (cell) {\n    //cell - cell component\n    const cellValue = cell.getValue();\n    const field = cell.getField();\n    console.log(cellValue, field)\n\n    const tree_table_data = body_table.getData();\n\n    const footer_table_data = footer_table.getData();\n\n    // body calcs\n\n    //console.log('tree_table_data',tree_table_data)\n\n    const new_tree = tree_table_data.map((p, p_index) =&gt; {\n      p[field] = cellValue\n        ? unique_cx_metrics.tree_summary_data.children[p_index][field]\n        : 0;\n      p.children = p.children.map((c, c_index) =&gt; {\n        c[field] = cellValue\n          ? unique_cx_metrics.tree_summary_data.children[p_index].children[\n              c_index\n            ][field]\n          : 0;\n        c.children = c.children.map((m, m_index) =&gt; {\n          m[field] = cellValue\n            ? unique_cx_metrics.tree_summary_data.children[p_index].children[\n                c_index\n              ].children[m_index][field]\n            : 0;\n          return m;\n        });\n        return c;\n      });\n      return p;\n    });\n\n    //console.log('new_tree',new_tree)\n\n    // footer calcs\n    footer_table_data[0][field] = cellValue\n      ? unique_cx_metrics.tree_summary_data[field]\n      : 0;\n\n    const total_cx_data = footer_table_data[0];\n\n    _.forIn(total_cx_data, (value, key) =&gt; {\n      if (key != \"cx\" && key != \"title\") {\n        footer_table_data[1][key] = +(\n          (value * 100) /\n          total_cx_data[\"cx\"]\n        ).toFixed(2);\n      }\n    });\n\n    //console.log(footer_table_data);\n\n    const unique_cx_data = calculate_unique_cx_summary(\n      new_tree,\n      unique_cx_metrics.devs_with_zero,\n      unique_cx_metrics.devs_with_non_zero\n    );\n\n    footer_table_data[2] = { ...unique_cx_data, title: \"Complejidad única\" };\n    \n\n    const percentage_unique_cx_data = _.transform(\n      unique_cx_data,\n      (result, value, key) =&gt; {\n        result[key] = +((value * 100) / total_cx_data[\"cx\"]).toFixed(2);\n      },\n      {}\n    );\n\n    footer_table_data[3] = {\n      ...percentage_unique_cx_data,\n      title: \"Complejidad única (%)\"\n    };\n\n    const knowledge_remaining = calculate_knowledge_remaining(new_tree, unique_cx_metrics.devs_with_non_zero);\n\n    const knowledge_remaining_percentage = 100 - (+((knowledge_remaining * 100) / total_cx_data[\"cx\"]).toFixed(2))\n\n    footer_table_data[4] = {\n      cx: knowledge_remaining_percentage,\n      title: \"Conocimiento restante\"\n    };\n\n    footer_table.replaceData(footer_table_data);\n    body_table.replaceData(tree_table_data);\n  });\n\n  // return\n  return holderEl;\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Experimentos</span>"
    ]
  },
  {
    "objectID": "chapters/ch03/experiments.html#apéndice",
    "href": "chapters/ch03/experiments.html#apéndice",
    "title": "3  Experimentos",
    "section": "3.2 Apéndice",
    "text": "3.2 Apéndice\n\n3.2.1 Variables y config\n\n\nCode\nchanges = selectedRepository[0].changes\n\n\n\n\n\n\n\n\n\nCode\nmutable footerdata = null;\n\n\n\n\n\n\n\n\n\nCode\nunique_cx_metrics = {\n  const grouped_data = d3.hierarchy(\n    changes_with_dev_key\n      .groupby(\"_package\", \"_class\", \"method\")\n      .orderby(aq.desc(\"date\"))\n      .derive({ last: aq.rolling((d) =&gt; op.first_value(d.cur_m_cx)) })\n      .orderby(\"date\")\n      .groupby(\"_package\", \"_class\", \"method\", \"last\")\n      .pivot({ key: (d) =&gt; d.dev_key }, { value: (d) =&gt; op.any(d.last) || 0 })\n      .groupby(\"_package\", \"_class\")\n      .objects({ grouped: \"map\" })\n  );\n\n  const tree_summary_data = grouped_data.copy().eachAfter((d) =&gt; {\n    devs_by_email.forEach((k) =&gt; {\n      d[k] = d.children ? _.sumBy(d.children, k) : d.data[k] || 0;\n    });\n\n    d[\"cx\"] = d.children ? _.sumBy(d.children, \"cx\") : d.data[\"last\"] || 0;\n\n    d.title = d.data[0] || d.data.method;\n  });\n\n  const { devs_with_zero, devs_with_non_zero } = _.chain(devs_by_email)\n    .partition((key) =&gt; _.every(tree_summary_data.children, (d) =&gt; d[key] == 0))\n    .map(_.sortBy)\n    .thru((v) =&gt; ({ devs_with_zero: v[0], devs_with_non_zero: v[1] }))\n    .value();\n\n  const picked = _.concat(devs_with_non_zero, [\"cx\"]);\n\n  const total_cx_data = _.pick(tree_summary_data, picked);\n\n  const percentage_cx_data = _.transform(\n    total_cx_data,\n    (result, value, key) =&gt; {\n      result[key] = +((value * 100) / total_cx_data[\"cx\"]).toFixed(2);\n    },\n    {}\n  );\n\n  const unique_cx_data = calculate_unique_cx_summary(\n    tree_summary_data.children,\n    devs_with_zero,\n    devs_with_non_zero\n  );\n\n  const percentage_unique_cx_data = _.transform(\n    unique_cx_data,\n    (result, value, key) =&gt; {\n      result[key] = +((value * 100) / total_cx_data[\"cx\"]).toFixed(2);\n    },\n    {}\n  );\n\n  const knowledge_remaining = calculate_knowledge_remaining(tree_summary_data.children,devs_with_non_zero);\n  const knowledge_remaining_percentage = 100 - (+((knowledge_remaining * 100) / total_cx_data[\"cx\"]).toFixed(2))\n\n  return {\n    grouped_data,\n    tree_summary_data,\n    devs_with_zero,\n    devs_with_non_zero,\n    total_cx_data,\n    percentage_cx_data,\n    unique_cx_data,\n    percentage_unique_cx_data,\n    knowledge_remaining,\n    knowledge_remaining_percentage\n  };\n}\n\n\n\n\n\n\n\n\n3.2.1.1 Limpiar devs\n\n\nCode\nchanges_with_dev_key = {\n  const changes_with_dev_email_splitted = aq.from(changes)\n    .derive({ splitted: (d) =&gt; op.split(d.dev_email, \"@\") })\n    .derive({ username: (d) =&gt; op.lower(d.splitted[0]) }) // normalize to lower\n    .derive({ domain: (d) =&gt; op.lower(d.splitted[1]) }) // normalize to lower\n    .derive({\n      new_email: (d) =&gt; d.username + (d.domain ? \"@\" + d.domain : \"\")\n    });\n\n  const changes_with_dev_email_splitted_objects =\n    changes_with_dev_email_splitted.objects();\n\n  const use_username =\n    _.chain(changes_with_dev_email_splitted_objects.map((d) =&gt; d.username))\n      .uniq()\n      .size()\n      .value() ==\n    _.chain(changes_with_dev_email_splitted_objects.map((d) =&gt; d.new_email))\n      .uniq()\n      .size()\n      .value();\n\n  return aq.from(changes_with_dev_email_splitted)\n    .derive({\n      dev_key: aq.escape((d) =&gt; (use_username ? d.username : d.new_email))\n    })\n    //.view();\n}\n\n\n\n\n\n\n\n\n\nCode\ndevs_by_email = changes_with_dev_key\n .dedupe('dev_key')\n .select('dev_key')\n .filter(d =&gt; d.dev_key !== \"noreply@github.com\" && d.dev_key !== \"noreply\") // filter noreply github\n .orderby('dev_key')\n .array('dev_key')\n\n\n\n\n\n\n\n\n\n\n3.2.2 Tabulator\n\n\nCode\nTabulator = require(\"tabulator-tables@5.5.2\")\n\n\n\n\n\n\n\n\n\n3.2.3 Helper Functions\n\n\nCode\ncreate_header = (metrics, containerId) =&gt; {\n  const data = _.chain(metrics.devs_with_non_zero)\n    .reduce((p, v) =&gt; ({ ...p, [v]: true }), {})\n    .thru((v) =&gt; [v])\n    .value();\n  \n  const container = document.createElement(\"DIV\");\n  container.id = containerId;\n  const table = new Tabulator(container, {\n    data: data,\n    layout: \"fitDataStretch\",\n    //height: 260,\n    headerSort: false,\n    nestedFieldSeparator: false,\n    columns: [\n      {\n        title: \"Software Item\",\n        headerSort: false,\n        width: 200,\n        responsive: 0,\n        frozen: true\n      },\n      ...metrics.devs_with_non_zero.map((d) =&gt; ({\n        title: d,\n        field: d,\n        hozAlign: \"center\",\n        headerSort: false,\n        editor: true,\n        width: 50,\n        headerVertical: \"flip\",\n        formatter: \"tickCross\"\n      })),\n      { title: \"Complejidad\", width: 150, headerSort: false }\n    ]\n  });\n  return table;\n}\n\n\n\n\n\n\n\n\n\nCode\ncreate_body = (metrics, containerId) =&gt; {\n  const data = _.cloneDeep(metrics.tree_summary_data).children;\n  //const footerElement = footer_table.element;\n  const container = document.createElement(\"DIV\");\n  container.id = containerId;\n\n  const table = new Tabulator(container, {\n    data,\n    dataTree: true,\n    dataTreeChildField: \"children\",\n    height: 350,\n    headerVisible: false, \n    layout: \"fitDataStretch\",\n    nestedFieldSeparator: false,\n    columns: [\n      {\n        title: \"Software Item\",\n        field: \"title\",\n        width: 200,\n        responsive: 0,\n        frozen: true\n      },\n\n      ...metrics.devs_with_non_zero.map((d) =&gt; ({\n        [\"title\"]: d,\n        [\"field\"]: d,\n        width: 50,\n        headerVertical: \"flip\"\n      })),\n      { title: \"Complejidad\", field: \"cx\", width: 150 }\n    ],\n    //footerElement: footerElement\n  });\n\n  return table;\n}\n\n\n\n\n\n\n\n\n\nCode\ncreate_footer = (metrics, containerId) =&gt; {\n  const data = [\n    {\n      title: \"Complejidad total\",\n      ...metrics.total_cx_data\n    },\n    {\n      title: \"Complejidad total (%)\",\n      ...metrics.percentage_cx_data\n    },\n    {\n      title: \"Complejidad única\",\n      ...metrics.unique_cx_data\n    },\n    {\n      title: \"Complejidad única (%)\",\n      ...metrics.percentage_unique_cx_data\n    },\n    {\n      title: \"Conocimiento restante\",\n      cx: metrics.knowledge_remaining_percentage\n    }\n  ];\n\n  const container = document.createElement(\"DIV\");\n  container.className = \"tabulator-footer\";\n  container.id = containerId;\n  const table = new Tabulator(container, {\n    data,\n    //height: 150,\n    layout: \"fitDataStretch\",\n    headerVisible: false,\n    nestedFieldSeparator: false,\n    cssClass: \"tabulator-footer\",\n    rowFormatter: function (row) {\n      const row_data = row.getData();\n      \n      if (row_data.title == \"Conocimiento restante\") {\n        if(row_data.cx &lt; riskPercentile){\n          row.getElement().style.backgroundColor = \"#ff0000\";\n          row.getElement().style.color = \"#fff\";\n          row.getElement().style.fontWeight = \"bold\";\n        }\n      }\n    },\n    columns: [\n      {\n        title: \"Software Item\",\n        field: \"title\",\n        width: 200,\n        responsive: 0,\n        frozen: true\n      },\n      ...metrics.devs_with_non_zero.map((d) =&gt; ({\n        [\"title\"]: d,\n        [\"field\"]: d,\n        width: 50,\n        headerVertical: \"flip\"\n      })),\n      { title: \"Complejidad\", field: \"cx\", width: 150 }\n    ]\n  });\n\n  return table;\n}\n\n\n\n\n\n\n\n\n\nCode\ncalculate_unique_cx_summary = (data, devs_with_zero, devs_with_non_zero) =&gt; {\n  const picked = _.concat(devs_with_non_zero);\n\n  let map = devs_with_non_zero.reduce((p, c) =&gt; {\n    return { ...p, [c]: 0 };\n  }, {});\n\n  //let cx = 0;\n  data.forEach((p, p_index) =&gt; {\n    p.children.forEach((c, c_index) =&gt; {\n      c.children.forEach((m, m_index) =&gt; {\n        //console.log(m)\n        const element = _.pick(m, picked);\n        const values = Object.values(element);\n        //console.log(element)\n        //console.log(values)\n        \n        const max = _.max(values);\n        const sum = _.sum(values);\n        const can = max == sum;\n        if (can && max != 0) {\n          //console.log('max',max, 'sum' , sum)\n          for (const [key, value] of Object.entries(element)) {\n            if (value == max) {\n              //console.log(key, value)\n              map[key] += value;\n              //console.log(map)\n              //cx = value;\n              break;\n            }\n          }\n        }\n      });\n    });\n  });\n\n  //map['cx'] = cx;\n\n  return map;\n}\n\n\n\n\n\n\n\n\n\nCode\ncalculate_knowledge_remaining = (data, devs_with_non_zero) =&gt; {\n  const picked = _.concat(devs_with_non_zero);\n\n  let result = 0;\n\n  data.forEach((p, p_index) =&gt; {\n    p.children.forEach((c, c_index) =&gt; {\n      c.children.forEach((m, m_index) =&gt; {\n        const element = _.pick(m, picked);\n        const values = Object.values(element);\n        \n        const all_zeros = _.every(values, d =&gt; d == 0);\n        \n        if (all_zeros) {\n          result += m['cx']\n        }\n      });\n    });\n  });\n\n  return result;\n}\n\n\n\n\n\n\n\n\n\n3.2.4 Fetchers\n\n\nCode\nrepos = {\n  const jgit_cookbook = {\n    repository: { name: \"java.jgit_cookbook\" },\n    changes: await FileAttachment(\"./../../data/java/changes_jgit_cookbook.json\").json()\n  };\n  \n  const uCrop = {\n    repository: { name: \"java.uCrop\" },\n    changes: await FileAttachment(\"./../../data/java/changes_uCrop.json\").json()\n  };\n  \n  const java_jwt = {\n    repository: { name: \"java.java_jwt\" },\n    changes: await FileAttachment(\"./../../data/java/changes_java_jwt.json\").json()\n  };\n  \n  const mapstruct = {\n    repository: { name: \"java.mapstruct\" },\n    changes: await FileAttachment(\"./../../data/java/changes_mapstruct.json\").json()\n  };\n\n  const modelmapper = {\n    repository: { name: \"java.modelmapper\" },\n    changes: await FileAttachment(\"./../../data/java/changes_modelmapper.json\").json()\n  };\n  \n  const javacv = {\n    repository: { name: \"java.javacv\" },\n    changes: await FileAttachment(\"./../../data/java/changes_javacv.json\").json()\n  };\n  \n  const spatial4j = {\n    repository: { name: \"java.spatial4j\" },\n    changes: await FileAttachment(\"./../../data/java/changes_spatial4j.json\").json()\n  };\n  \n  const google_http_java_client = {\n    repository: { name: \"java.google_http_java_client\" },\n    changes: await FileAttachment(\"./../../data/java/changes_google_http_java_client.json\").json()\n  };\n  \n  const jadx = {\n    repository: { name: \"java.jadx\" },\n    changes: await FileAttachment(\"./../../data/java/changes_jadx.json\").json()\n  };\n  \n  \n  return [\n    jgit_cookbook, \n    uCrop,\n    java_jwt,\n    mapstruct,\n    modelmapper,\n    javacv,\n    spatial4j,\n    google_http_java_client,\n    jadx\n  ];\n}\n\n\n\n\n\n\n\n\n\n3.2.5 Imports\n\n\nCode\nd3 = require(\"d3@7\")\n\n\n\n\n\n\n\n\n\n3.2.6 Notebook Imports\n\n\nCode\nimport { aq, op } from '@uwdata/arquero'",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Experimentos</span>"
    ]
  }
]